# 链表

传统的`struct ListNode`在`new`动态开辟数组的时候，速度太慢，容易超时。如果已知长度，最好使用静态链表

* 单链表：邻接表： 存储图，存储树
* 双链表



----

静态单链表：e[N] 存储数组中的值，用 ne[N]来存储结点的`next`指针，idx表示当前用到了哪个结点。

`e[] 和ne[] `用下标关联起来。具体规则如下：空集用-1来表示。

![image-20210713214318448](.\链表.assets\image-20210713214312152.png)



## Acwing 826, 单链表操作模板题目：

```c++
#include<iostream>
#include<string>
using namespace std;

const int N = 1e5 + 10;

int e[N],ne[N], head, idx;

void insertHead(int x){
    e[idx] = x;
    ne[idx] = head;
    head = idx;
    idx ++;

}

void insertK(int k,int x){
    e[idx] = x;
    ne[idx] = ne[k];
    ne[k] = idx;
    idx++;
}

void deleteK(int k){
    // 注意，在第k个插入的数的后一个数，不一定是第k+1个插入的数，不能写成ne[k] = ne[k + 1]
    ne[k] = ne[ne[k]];
}

void printAll()
{
    // 注意边界条件 i != -1 ， 而不是e[i] != -1;
    for(int i = head; i != -1; i = ne[i]){
        printf("%d ",e[i]);
    }
}

int main(){
    int m;
    cin >> m;
    head = -1;
    idx = 0;
    while( m --){
        int k,x;
        char op;
        cin >> op;
        //注意switch语句中，op只能是char或者int类型
        switch( op ){
            case 'H':
                cin >> x;
                insertHead(x);
                break;

            case 'I':
                cin >> k >> x;
                // 注意这里的下标要减一，因为原数组是从下标0开始
                insertK(k - 1,x);
                break;

            case 'D':
                cin >> k;
                // 删除头结点需要单独考虑
                if( k == 0){
                    head = ne[head]; 
                }else{
                    deleteK(k - 1);
                }

                break;

        }
    }
    printAll();


    return 0;
}
```



## 双链表：Acwing 827模板题

* 双链表的题型跟单链表类似，也用数组来实现，但是此时需要三个数组`e[N],l[N],r[N]`，分别存储所在下标的值，左链接的下标，右链接的下标。
* 使用下标为0作为左端点，下标1作为右端点。

```c++
#include<iostream>
#include<string>
using namespace std;

const int N = 100010;

int e[N], l[N], r[N], idx;

void initial() {
    // 下标0作为左端点，下标1作为右端点
    r[0] = 1;
    l[1] = 0;
    idx = 2;
}

void insert(int k, int x) {
    e[idx] = x;
    r[idx] = r[k];
    l[idx] = k;
    // 注意下面两步的顺序一定不能出错，先判断k的右结点的左线 = 新插入位置
    // k结点的右连线更改为新插入位置
    l[r[k]] = idx;
    r[k] = idx;
    idx++;
}

void remove(int k) {
    l[r[k]] = l[k];
    r[l[k]] = r[k];
}


void printAll() {
    for (int i = r[0]; i != 1; i = r[i]) {
        printf("%d ", e[i]);
    }
}

int main() {
    int m;
    cin >> m;
    int k, x;
    initial();
    while (m--) {
        string op;
        cin >> op;
        if (op == "R") {
            cin >> x;
            insert(l[1], x);
        }
        else if (op == "L") {
            cin >> x;
            insert(0, x);
        }
        else if (op == "D") {
            cin >> k;
            remove(k + 1);
        }
        else if (op == "IL") {
            cin >> k >> x;
            insert(l[k + 1], x);
        }
        else {
            //op == "IR"
            cin >> k >> x;
            insert(k + 1, x);
        }
    }
    printAll();
    return 0;
}
```





## leetcode 141 环形链表1

给你一个链表的头节点 `head` ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 `pos` 是 -1，则在该链表中没有环。注意：`pos` 不作为参数进行传递，仅仅是为了标识链表的实际情况。

如果链表中存在环，则返回`true` 。 否则，返回 `false` 。
链接：https://leetcode-cn.com/problems/linked-list-cycle

![image-20211124203804339](C:\Users\blessyuuu\AppData\Roaming\Typora\typora-user-images\image-20211124203804339.png)

**思路：**

利用快慢双指针法，时间复杂度为O(n).

慢指针从head开始，每次前进一步，快指针从`head`开始，每次行动两步。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        // 如果head为空或者没有next（只有一个节点），肯定无环
        if(!head || !head -> next)  return false;
        auto s = head, f = head -> next;
        while(f){
            s = s -> next;
            f = f -> next;
            // 如果快指针走到末尾，为NULL了
            if(!f) return false;
            f = f -> next;
            // 如果slow和fast指针相遇，则一定有环
            if(s == f){
                return true;
            }
        }
        return false;
    }
};
```





## Leetcode 142环形链表2

**环形链表2**:给定一个链表，返回链表开始入环的**第一个节点**。 如果链表无环，则返回 `null`。

[142. 环形链表 II - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

思路：

![image-20211124204958264](C:\Users\blessyuuu\AppData\Roaming\Typora\typora-user-images\image-20211124204958264.png)

快慢指针都从head开始，与上一题不同的是，如何找“入环点”？

设A点是入环点，B点是快慢指针相遇的点，当慢节点走了`x + y` 步到达B点时，快节点走了`2 * (x + y)` 步，不妨可以假设一点C，从A到C经过的步数是`X`。从`C`走到入环点A也有`y`步。

那么当快慢指针相遇的时候，把慢指针退回到head处，快指针在B点不动，这样当两者再次相遇时，所遇到的节点就是入环点。



```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        if(!head || !head->next)    return NULL;
        // 快慢指针都从head节点开始
        auto s = head, f = head;
        while(f){
            s = s -> next;
            f = f -> next;
            if(!f)  return NULL;
            f = f -> next;  
            // 关键
            if( s == f){
                s = head;
                while( s != f){
                    s = s-> next;
                    f = f -> next;
                }
                return s;
            }
        }
        return NULL;
    }
};
```



### 

## 经典面试题： 反转链表

定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。

**思考题：**

- 请同时实现迭代版本和递归版本。

#### 数据范围

链表长度 `[0,30]`。

#### 样例

```
输入:1->2->3->4->5->NULL

输出:5->4->3->2->1->NULL
```



1. 迭代版本

![image-20220217200911205](链表.assets/image-20220217200911205.png)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        // 特判head为空和只存在一个结点的时候
        if(!head || !head -> next)  return head;
        auto pre_node = head, cur_node = head -> next;
        // 当cur_node不为空的时候
        while(cur_node){
            auto nx_node = cur_node -> next;
            cur_node -> next = pre_node;
            pre_node = cur_node, cur_node = nx_node;
        }
        head -> next = NULL;
        return pre_node;
    }
};

```



重点关注递归版本：

首先考虑`reverseList`函数能做什么，它能够将当前的head结点到最后的结点中的所有结点连接关系翻转，并返回新链表的头结点，也就是原链表的尾结点。

所以我们可以先递归处理 `reverseList(head->next)`，这样我们可以将以`head->next`为头节点的链表翻转，并得到原链表的尾节点tail，此时head->next是新链表的尾节点，我们令它的next指针指向head，并将head->next指向空即可将整个链表翻转，且新链表的头节点是tail。

时间复杂度：链表中每个节点被遍历一次，时间复杂度O(n)。 空间复杂度：总共递归n层，系统栈的空间复杂度O(n), 所以总共需要额外O(n)的空间。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (!head || !head->next) return head;
        ListNode *tail = reverseList(head->next);
        // 下面这一步很重要
        head->next->next = head;
        head->next = nullptr;
        return tail;
    }
};
```

