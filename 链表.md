## 链表

传统的`struct ListNode`在`new`动态开辟数组的时候，速度太慢，容易超时。如果已知长度，最好使用静态链表

* 单链表：邻接表： 存储图，存储树
* 双链表



----

静态单链表：e[N] 存储数组中的值，用 ne[N]来存储结点的`next`指针，idx表示当前用到了哪个结点。

`e[] 和ne[] `用下标关联起来。具体规则如下：空集用-1来表示。

![image-20210713214318448](.\链表.assets\image-20210713214312152.png)



Acwing 826, 单链表操作模板题目：

```c++
#include<iostream>
#include<string>
using namespace std;

const int N = 1e5 + 10;

int e[N],ne[N], head, idx;

void insertHead(int x){
    e[idx] = x;
    ne[idx] = head;
    head = idx;
    idx ++;

}

void insertK(int k,int x){
    e[idx] = x;
    ne[idx] = ne[k];
    ne[k] = idx;
    idx++;
}

void deleteK(int k){
    ne[k] = ne[ne[k]];
}

void printAll()
{
    // 注意边界条件 i != -1 ， 而不是e[i] != -1;
    for(int i = head; i != -1; i = ne[i]){
        printf("%d ",e[i]);
    }
}

int main(){
    int m;
    cin >> m;
    head = -1;
    idx = 0;
    while( m --){
        int k,x;
        char op;
        cin >> op;
        //注意switch语句中，op只能是char或者int类型
        switch( op ){
            case 'H':
                cin >> x;
                insertHead(x);
                break;

            case 'I':
                cin >> k >> x;
                // 注意这里的下标要减一，因为原数组是从下标0开始
                insertK(k - 1,x);
                break;

            case 'D':
                cin >> k;
                // 删除头结点需要单独考虑
                if( k == 0){
                    head = ne[head]; 
                }else{
                    deleteK(k - 1);
                }

                break;

        }
    }
    printAll();


    return 0;
}
```





* 双链表的题型跟单链表类似，也用数组来实现，但是此时需要三个数组`e[N],l[N],r[N]`，分别存储所在下标的值，左链接的下标，右链接的下标。
* 不妨使用下标为0作为左端点，下标1作为右端点。

例题：Acwing 827模板题



```c++
#include<iostream>
#include<string>
using namespace std;

const int N = 100010;

int e[N], l[N], r[N], idx;

void initial() {
    // 下标0作为左端点，下标1作为右端点
    r[0] = 1;
    l[1] = 0;
    idx = 2;
}

void insert(int k, int x) {
    e[idx] = x;
    r[idx] = r[k];
    l[idx] = k;
    // 注意下面两步的顺序一定不能出错，先判断k的右结点的左线 = 新插入位置
    // k结点的右连线更改为新插入位置
    l[r[k]] = idx;
    r[k] = idx;
    idx++;
}

void remove(int k) {
    l[r[k]] = l[k];
    r[l[k]] = r[k];
}


void printAll() {
    for (int i = r[0]; i != 1; i = r[i]) {
        printf("%d ", e[i]);
    }
}

int main() {
    int m;
    cin >> m;
    int k, x;
    initial();
    while (m--) {
        string op;
        cin >> op;
        if (op == "R") {
            cin >> x;
            insert(l[1], x);
        }
        else if (op == "L") {
            cin >> x;
            insert(0, x);
        }
        else if (op == "D") {
            cin >> k;
            remove(k + 1);
        }
        else if (op == "IL") {
            cin >> k >> x;
            insert(l[k + 1], x);
        }
        else {
            //op == "IR"
            cin >> k >> x;
            insert(k + 1, x);
        }
    }
    printAll();
    return 0;
}
```

