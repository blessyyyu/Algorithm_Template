## 二分查找

二分查找的本质在于：

* 有一列“有序”数组，其中所有的元素被“某一性质”分成了两部分，需要找到其中某个元素的分界线。
* 当`l = r`时，即找到目标值。



### 整数二分

整数二分需要特别注意边界问题，有以下两个模板：

```c++
int a[];
int b_search1(int l, int r){
    while( l < r){
        int mid = l + r >> 1;
        if( check(mid) )	r = mid;
        else	l = mid + 1;
    }
    return l;
}


int b_search2(int l , int r){
    while ( l < r){
        int mid = l + r + 1 >> 1;
        if ( check(mid) )  l = mid;
        else	r = mid - 1;
    }
    return l;
}
```



* 两个模板中的 `check(mid)`函数都非常重要，因为二分法不断迭代，最终会落到最接近target的那个数上面。

1. 定义check条件。如果判断mid < target, 那么找到的是小于target但是最接近target的数，就是小于target的最大数。如果判断**mid >= target**, 那么找到的是大于或者**等于target**的最接近target的数，就是target或者比target大的最小数。所以`check(mid)`函数中一般都需要写`>= or <=`
2. 根据check的定义，然后压缩左右边界，确定要哪一边。





* 第一个模板用于， 当 mid 元素的性质属于前半部分时，如图所示：

![image-20210711213545418](.\二分查找.assets\image-20210711213545418.png)

第一个模板`int mid = l + r >> 1`即可。



* 第二个模板用于，mid元素的性质属于后一半部分，如图所示：

![image-20210711213820727](.\二分查找.assets\image-20210711213820727.png)

此时一定要注意`int mid = l + r + 1 >> 1` , 否则使用`l + r >> 1`容易出现死循环问题:

当元素最后只剩下两个元素时：

![image-20210711214208479](.\二分查找.assets\image-20210711214206563.png)



### 浮点数二分

```c++
double b_search3(double l, double r){
    while( r - l > 1e-8){
        double mid = (r + l ) / 2;
        if( check(mid) )   r = mid;
        else	l = mid;
    }
    return l;
}
```

浮点数二分需要注意的点：

* r和l设置为数的最大范围的两边。

* 输出精度的确定：如果要求保留小数点后的位数是6，一般r - l > $10^{-8}$ ; 多2是比较保险的做法
* 传参数的$ l 和 r$ 要注意，如果题目是二分取平方根，小数的平方根会比原来的数要大，这样就超过了右边界。比如：0.01的平方根是0.1。 所以右边界常取为`max(1,x)`