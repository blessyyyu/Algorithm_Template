### 哈夫曼树（Huffman Tree）

在一个果园里，达达已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。

达达决定把所有的果子合成一堆。

每一次合并，达达可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。

可以看出，所有的果子经过 n−1 次合并之后，就只剩下一堆了。

达达在合并果子时总共消耗的体力等于每次合并所耗体力之和。

因为还要花大力气把这些果子搬回家，所以达达在合并果子时要尽可能地节省体力。

假定每个果子重量都为 1，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使达达耗费的体力最少，并输出这个最小的体力耗费值。

例如有 3 种果子，数目依次为 1，2，9。

可以先将 1、2 堆合并，新堆数目为 3，耗费体力为 3。

接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 12，耗费体力为 12。

所以达达总共耗费体力=3+12=15。

可以证明 15 为最小的体力耗费值。

#### 输入格式

输入包括两行，第一行是一个整数 n，表示果子的种类数。

第二行包含 n 个整数，用空格分隔，第 i 个整数 $a_i$ 是第 i 种果子的数目。

#### 输出格式

输出包括一行，这一行只包含一个整数，也就是最小的体力耗费值。

输入数据保证这个值小于 $2^{31}$

#### 数据范围

1≤n≤10000,
$1≤a_i≤20000$

#### 输入样例：

```
3 
1 2 9 
```

#### 输出样例：

```                                    
15
```

#### 思路与解答

Huffman编码的思路：

每次选择最小的两堆进行合并，这样合并的代价值最小。

使用优先级队列（堆）来完成，每次操作涉及两次出堆和一次入堆，时间复杂度为$O(logn)$， 最后的时间复杂度为$O(nlogn)$



```c++
#include<bits/stdc++.h>

using namespace std;

priority_queue<int, vector<int> , greater<int>> q;

int main(){
    int n;
    scanf("%d", &n);
    while(n--){
        int x;
        scanf("%d", &x);
        q.push(x);
    }
    
    int res = 0;
    while(q.size() > 1){
        int least = q.top();
        q.pop();
        int sec_least = q.top();
        q.pop();
        res += least + sec_least;
        q.push(least + sec_least);
    }
    
    cout << res<<endl;
    return 0;
}
```



### 排队打水

有 n 个人排队到 1 个水龙头处打水，第 i 个人装满水桶所需的时间是 $t_i$，请问如何安排他们的打水顺序才能使所有人的等待时间之和最小？

#### 输入格式

第一行包含整数 n。

第二行包含 n 个整数，其中第 i 个整数表示第 i 个人装满水桶所花费的时间 $t_i$。

#### 输出格式

输出一个整数，表示最小的等待时间之和。

#### 数据范围

$1≤n≤10^5,$

$1≤t_i≤10^4$

#### 输入样例：

```
7
3 6 1 4 2 5 7
```

#### 输出样例：

```
56
```



#### 思路与解答

结论： 按照等待时间从小到大排序，这样所有人的等待时间之和是最小的。

如样例中：等待时间排序后为`1,2,3,4,5,6,7`, 他们的等待时间分别是: `0,1,3,6,10,15,21`； 和为56. 

证明：按照贪心算法的基本证明理论来求解，设该贪心方案得到的结果是`res`, 真实的最小等待时间是`ans`, 要证明`res == ans`, 即要证:`res >= ans和 res <= ans`. 而这两个不等式里，往往有一边已经根据题意满足了，只要证明另一边即可。  而证明另一边的方法，通常使用**反证法**。



```c++
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 100010;

int n;
int t[N];

bool cmp(int a, int b){
    return a > b;
}

int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ ) scanf("%d", &t[i]);

    // 按照从大到小排序
    sort(t, t + n,cmp);

    LL res = 0;
    // 最大的接水时间不需要等待
    for (int i = 0; i < n; i ++ ) res += t[i] * i;

    printf("%lld\n", res);

    return 0;
}

```





### 货仓选址

在一条数轴上有 N 家商店，它们的坐标分别为 $A_1∼A_N$。

现在需要在数轴上建立一家货仓，每天清晨，从货仓到每家商店都要运送一车商品。

为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。

#### 输入格式

第一行输入整数 N。

第二行 N 个整数 $A_1∼A_N$。

#### 输出格式

输出一个整数，表示距离之和的最小值。

#### 数据范围

$1≤N≤100000$
$0≤A_i≤40000$

#### 输入样例：

```
4
6 2 9 1
```

#### 输出样例：

```
12
```



#### 思路与解答

结论：

先将商店的坐标按照从小到大排序；

当整个商店的数量为偶数时，选择最中间两个商店的坐标的正中间为货仓选址。

当整个商店的数量为奇数时，货仓就选在最中间的商店处。



```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010;

int n;
int q[N];

int main()
{
    scanf("%d", &n);

    for (int i = 0; i < n; i ++ ) scanf("%d", &q[i]);

    sort(q, q + n);

    int res = 0;
    // abs
    for (int i = 0; i < n; i ++ ) res += abs(q[i] - q[n / 2]);

    printf("%d\n", res);

    return 0;
}

```











### 推公式

农民约翰的 N 头奶牛（编号为 1..N）计划逃跑并加入马戏团，为此它们决定练习表演杂技。

奶牛们不是非常有创意，只提出了一个杂技表演：

叠罗汉，表演时，奶牛们站在彼此的身上，形成一个高高的垂直堆叠。

奶牛们正在试图找到自己在这个堆叠中应该所处的位置顺序。

这 $N$ 头奶牛中的每一头都有着自己的重量 $W_i$ 以及自己的强壮程度 $S_i$。

一头牛支撑不住的可能性取决于它头上所有牛的总重量（不包括它自己）减去它的身体强壮程度的值，现在称该数值为风险值，风险值越大，这只牛撑不住的可能性越高。

您的任务是确定奶牛的排序，使得所有奶牛的风险值中的最大值尽可能的小。

#### 输入格式

第一行输入整数 N，表示奶牛数量。

接下来 N 行，每行输入两个整数，表示牛的重量和强壮程度，第 i 行表示第 i 头牛的重量 $W_i$ 以及它的强壮程度$S_i$。

#### 输出格式

输出一个整数，表示最大风险值的最小可能值。

#### 数据范围

$1≤N≤50000,$
$1≤W_i≤10,000,$
$1≤S_i≤1,000,000,000$

#### 输入样例：

```
3
10 3
2 5
3 3
```

#### 输出样例：

```
2
```



#### 思路与解答

结论：将所有牛按照 w+s 的大小，从小到大排序，小的放在最上面，大的放最下面。



```c++
#include<bits/stdc++.h>

using namespace std;

const int N = 5e4 + 10;

typedef pair<int,int> PII;

PII cow[N];
int n;
int main(){
    cin >> n;
    for(int i = 0; i < n; i ++)
    {
        int w,s;
        cin >> w >> s;
        cow[i] = {s + w, w};
    }
    
    sort(cow, cow + n);
    int res = -2e9, sum = 0;
    for(int i = 0; i < n; i ++){
        int s = cow[i].first - cow[i].second;
        res = max(res, sum - s);
        sum += cow[i].second;
    }
    
    cout << res << endl;
    
    return 0;
}
```







