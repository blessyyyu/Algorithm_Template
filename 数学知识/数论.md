# 数论

## 质数

质数：是根据所有大于1的自然数来定义的，所以从2开始判断一个数是否是质数。

所有小于等于1的数，既不是质数也不是合数。

定义：如果只包含1和本身这两个约数，那么就称做是质数。



### 质数的判定：

试除法：时间复杂度O(sqrt(n))  关键在于for循环里条件的判断语句

```c++
bool is_prime(int n){
    if(n < 2)	return false;
    for(int i = 2; i <= n / i; i ++){
        if(n % i ==0)
            return false;
    }
    return true;
}

/*
for( ; i <= sqrt(n);  )		// 不好，因为sqrt(n)  速度慢
for( ; i*i <= n ;)		//不好，因为当i接近于int的最大值时, i * i就是一个负数
*/
```



### 分解质因数

试除法 最坏$O(sqrt(n))$， 实际$[O(logn) , O(sqrt(n))]$, 左端点是因为，如果一个数恰好是2^n， 那么就不断的除以2就可以分解成功。

算数基本定理：任何大于1的正整数都能==唯一==的分解为有限个质数的乘积。根据这一定理，任何一个合数都可以被分解成几个质数相乘的形式。

思想：从小到大枚举所有的数**d**, 如果 **d** 可以整除**n**, 则从**n**中除掉所有的因子**d**，同时累计除去**d**的个数。通过唯一分解定理，可以知道一个合数的因子一定在扫描到这个合数之前就被其更小的质因子**d**除掉了，所以能整除**n**的数一定是质数。

并且n中最多只包含一个大于sqrt(n)的质因子；

质因子若重复，可以使用指数来表示。



#### 经典例题：

给定 n 个正整数 $a_i$，将每个数分解质因数，并按照质因数从小到大的顺序输出每个质因数的底数和指数。

#### 输入格式

第一行包含整数 n。

接下来 n 行，每行包含一个正整数$a_i$。

#### 输出格式

对于每个正整数 $a_i$，按照从小到大的顺序输出其分解质因数后，每个质因数的底数和指数，每个底数和指数占一行。

每个正整数的质因数全部输出完毕后，输出一个空行。

#### 数据范围

1≤n≤100,
1≤$a_i$≤2×10^9

#### 输入样例：

```
2
6
8
```

#### 输出样例：

```
2 1
3 1

2 3
```

#### 解答：

```c++
#include<bits/stdc++.h>

using namespace std;


void divide(int n){
    for(int i = 2; i <= n / i; i++){
        if(n % i == 0){
            int s = 0;
            while(n % i == 0){
                s++;
                n /= i;
            }
            printf("%d %d\n", i, s);
        }

    }
    if(n > 1)   printf("%d %d\n", n , 1);
    puts("");
}

int main(){
    int n;
    scanf("%d", &n);
    while(n--){
        int x;
        scanf("%d", &x);
        divide(x);
    }
    
    return 0;
}
```



### 筛质数

题目是从1~n中统计所有的质数数量。

埃氏筛法：从1 ~n中依次删除2的倍数，3的倍数，...., 从而得到1~n中所有的质数。 时间复杂度$O(nloglogn)$

```c++
int cnt;
// st数组用来避免重复筛选，st[i]==false，表明这个数是质数或者未定；否则st[i] == true表示为合数
bool st[N];
void get_primes(int n){
    for(int i = 2; i <= n; i ++){
        if(!st[i]){
            cnt++;
            for(int j = i + i; j <=n; j += i) st[j] = true;
        }
    }
}
```



线性筛法：时间复杂度约等于$O(n)$， **x只会被其最小的质因子筛去**。很棒的算法！

```c++
int cnt,primes[N];
bool st[N];
// primes[]数组存储的是从小到大的所有质数
void get_primes(int n){
    for(int i = 2; i<= n; i++){
        if(!st[i])	primes[cnt++] = i;
        for(int j = 0; primes[j] <= n / i; j++){
            st[primes[j] * i] = true;			   //用st[]数组的true和false来表示是否已经被筛掉
            if( i % primes[j] == 0)	break;			// 1. break表示：primes[j]一定是i的最小质因子， 因为primes[j]是从j = 0开始的，所以
            										// primes[j] * i 一定是以primes[j]为最小质因子的合数
            										// 2. 当i % primes[j] != 0时，说明primes[j] 小于i的最小质因子，那么primes[j]也一													// 定是primes[j] * i 的最小质因子 
        }
    }
}
```





## 约数

约数：如果一个数`y`能整除`x`，那么`y`就是`x`的一个约数。



### 试除法

试除法的思想：如果数`d`可以整除`n`， 那么`n/d` 也能整除`n`。





### 约数个数

约数个数和约数之和两个算法都是基于算术基本定理，质因数分解。

所有int范围内的整数，所有约数个数最多是1500个左右。

约数个数公式：基于算数基本定理，如果把数N质因子分解后的结果看成连乘形式。

$ N = P_{1}^{a_1}P_{2}^{a_2}P_{3}^{a_3}...P_{k}^{a_k} $ , 那么它的约数个数=  $(a_{1} + 1)(a_{2} + 1)(a_{3} + 1)...(a_{k} + 1)$  

推导公式：
$$
N = P_{1}^{a_1}P_{2}^{a_2}P_{3}^{a_3}...P_{k}^{a_k} \\
P_{1}^{a_1}的约数个数 = a_{1} + 1; (比如8 = 2^{3}, 那么8的约数有2^{0}, 2^{1}, 2^{2}, 2^{3}) \\
同理， P_2^{a_2}的约数个数 = a_{2} + 1; \\
最后总的约数个数quntity(n)=(a_1+1)(a_2+1)...(a_k+1)
$$

### 经典例题:约数个数

给定 n 个正整数 $a_i$，请你输出这些数的乘积的约数个数，答案对 $10^9+7$ 取模。

#### 输入格式

第一行包含整数 n。

接下来 n 行，每行包含一个整数 $a_i$。

#### 输出格式

输出一个整数，表示所给正整数的乘积的约数个数，答案需对 $10^9+7$取模。

#### 数据范围

$$1≤n≤100, \\
1≤a_i≤2×10^9 $$

#### 输入样例：

```
3
2
6
8
```

#### 输出样例：

```
12
```

#### 解答： 

比如例题中2，6，8； 相乘起来是 2 * 6 * 8， 分别将其分解质因数后为 ： $2^1, 2*3 , 2^3$, 最后的map中存储； map[2] = 5, map[3] =  1;

最终结果为： (5 + 1) * (1+ 1) = 12

```c++
#include<bits/stdc++.h>

using namespace std;

unordered_map<int,int> primes;
typedef long long LL;

const int mod = 1e9 + 7;
int main(){
    int n;
    cin >> n;
    while(n --){
        int x;
        cin >> x;
        for(int i = 2; i <= x / i; i ++){
            while(x %i == 0){
                x /= i;
                primes[i]++;
            }
        }
        // 这里是当i 接近于x的时候，for( ; condition;)condition不成立，但是x仍是一个质数
        if(x > 1)  primes[x] ++;
    }
    LL res = 1;
    for(auto prime : primes){
        res = res *(prime.second + 1) % mod;
    }

    cout << res << endl;

    return 0;
}

```







### 约数之和

约数之和公式：

$ N = P_{1}^{a_1}P_{2}^{a_2}P_{3}^{a_3}...P_{k}^{a_k} $ 

$Sum = (p_{1}^0 + p_{1}^1 +... + p_{1}^{a_1}) *... *(p_{k}^0 + p_{k}^1 +... + p_{k}^{a_k})$



#### 解答

$(p_{1}^0 + p_{1}^1 +... + p_{1}^{a_1})$ 用代码实现就是：

`while(a --) t = (t * p + 1)` 因为如果a = 1, 则t = p + 1, 如果a = 2, t =  p(p + 1) + 1 = p^2 + p + 1; 依此类推，得到 $ p^a + p^{a-1} + p^{a-2} + .... + p^{0}$

```c++
#include<bits/stdc++.h>

using namespace std;

unordered_map<int,int> primes;
typedef long long LL;

const int mod = 1e9 + 7;
int main(){
    int n;
    cin >> n;
    while(n --){
        int x;
        cin >> x;
        for(int i = 2; i <= x / i; i ++){
            while(x %i == 0){
                x /= i;
                primes[i]++;
            }
        }
        // 这里是当i 接近于x的时候，for( ; condition;)condition不成立，但是x仍是一个质数
        if(x > 1)  primes[x] ++;
    }
    LL res = 1;
    for(auto prime : primes){
        int p = prime.first, a = prime.second;
        LL t = 1;           // 初始值为1
        // 下面的while循环的用法注意
        while(a --) t = (t * p + 1) % mod;		
        res = res * t % mod;
    }

    cout << res << endl;

    return 0;
}
```



### 求最大公约数

使用欧几里得算法：

```c++
#include<bits/stdc++.h>

using namespace std;

const int N = 1e5 + 10;

int gcd(int a, int b){
    if(a % b == 0)  return b;
    else{
        return gcd(b, a % b);
    }
}

int main(){
    int n;
    cin >> n;
    while(n--){
        int a,b;
        cin >> a >> b;
        cout << gcd(a,b)<<endl;
    }
    
    return 0;
}
```



