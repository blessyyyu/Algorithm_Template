# 数论

## 质数

质数：是根据所有大于1的自然数来定义的，所以从2开始判断一个数是否是质数。

所有小于等于1的数，既不是质数也不是合数。

定义：如果只包含1和本身这两个约数，那么就称做是质数。



### 质数的判定：

试除法：时间复杂度O(sqrt(n))  关键在于for循环里条件的判断语句

```c++
bool is_prime(int n){
    if(n < 2)	return false;
    for(int i = 2; i <= n / i; i ++){
        if(n % i ==0)
            return false;
    }
    return true;
}

/*
for( ; i <= sqrt(n);  )		// 不好，因为sqrt(n)  速度慢
for( ; i*i <= n ;)		//不好，因为当i接近于int的最大值时, i * i就是一个负数
*/
```



### 分解质因数

试除法 最坏$O(sqrt(n))$， 实际$[O(logn) , O(sqrt(n))]$, 左端点是因为，如果一个数恰好是2^n， 那么就不断的除以2就可以分解成功。

算数基本定理：任何大于1的正整数都能==唯一==的分解为有限个质数的乘积。根据这一定理，任何一个合数都可以被分解成几个质数相乘的形式。

思想：从小到大枚举所有的数**d**, 如果 **d** 可以整除**n**, 则从**n**中除掉所有的因子**d**，同时累计除去**d**的个数。通过唯一分解定理，可以知道一个合数的因子一定在扫描到这个合数之前就被其更小的质因子**d**除掉了，所以能整除**n**的数一定是质数。

并且n中最多只包含一个大于sqrt(n)的质因子；

质因子若重复，可以使用指数来表示。



#### 经典例题：

给定 n 个正整数 $a_i$，将每个数分解质因数，并按照质因数从小到大的顺序输出每个质因数的底数和指数。

#### 输入格式

第一行包含整数 n。

接下来 n 行，每行包含一个正整数$a_i$。

#### 输出格式

对于每个正整数 $a_i$，按照从小到大的顺序输出其分解质因数后，每个质因数的底数和指数，每个底数和指数占一行。

每个正整数的质因数全部输出完毕后，输出一个空行。

#### 数据范围

1≤n≤100,
1≤$a_i$≤2×10^9

#### 输入样例：

```
2
6
8
```

#### 输出样例：

```
2 1
3 1

2 3
```

#### 解答：

```c++
#include<bits/stdc++.h>

using namespace std;


void divide(int n){
    for(int i = 2; i <= n / i; i++){
        if(n % i == 0){
            int s = 0;
            while(n % i == 0){
                s++;
                n /= i;
            }
            printf("%d %d\n", i, s);
        }

    }
    if(n > 1)   printf("%d %d\n", n , 1);
    puts("");W
}

int main(){
    int n;
    scanf("%d", &n);
    while(n--){
        int x;
        scanf("%d", &x);
        divide(x);
    }
    
    return 0;
}
```



### 筛质数

埃氏筛法：从1 ~n中依次删除2的倍数，3的倍数，...., 从而得到1~n中所有的质数。 时间复杂度$O(nloglogn)$

```c++
int cnt, st[N];
void get_primes(int n){
    for(int i = 2; i <= n; i ++){
        if(!st[i]){
            cnt++;
            for(int j = i + i; j <=n; j += i) st[j] = true;
        }
    }
}
```



线性筛法：

```c++
void get_primes(int n){
    for(int i = 2; i<= n; i++){
        if(!st[i])	primes[cnt++] = i;
        for(int j = 0; primes[j] <= n / i; j++){
            st[primes[j] * i] = true;
            if( i % primes[j] == 0)	break;
        }
    }
}
```



