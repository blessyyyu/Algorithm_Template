# 组合计数-容斥原理-简单博弈论

## 组合计数

两个公式：

公式1： $C_{a}^{b} = \frac{a\times(a-1) \times ... \times(a - b + 1)}{ 1 \times 2 \times 3 ... \times b}$

公式2： $C_{a}^{b} = C_{a-1}^{b-1} + C_{a-1}^{b}$

并且组合计数，一定要考虑数据范围。

### 例题：组合计数1

给定 n 组询问，每组询问给定两个整数 a，b，请你输出 $C_{a}^{b}mod(10^9+7)$的值。

#### 输入格式

第一行包含整数 n。

接下来 n 行，每行包含一组 a 和 b。

#### 输出格式

共 n 行，每行输出一个询问的解。

#### 数据范围

1≤n≤10000,
1≤b≤a≤2000

#### 输入样例：

```
3
3 1
5 3
2 2
```

#### 输出样例：

```
3
10
1
```



时间复杂度最大为：$O(a^2)≈ 4e6$级别

```c++
#include<bits/stdc++.h>

using namespace std;

const int N = 2010, mod = 1e9 + 7;

int c[N][N];

void init(){
    for(int i = 0; i < N; i ++)
        for(int j = 0; j <= i; j++)					// j <= i 就是C的上限的数不能超过下面的数。
            if(!j)  c[i][j] = 1;
            else    c[i][j] = (c[i-1][j] + c[i - 1][j - 1]) % mod;
}

int main(){
    init();
    int n;
    cin >> n;
    while( n --){
        int a,b;
        cin >> a>> b;
        cout << c[a][b]<< endl;
    }
    return 0;
}
```



### 例题2：组合计数2

给定 n 组询问，每组询问给定两个整数 a，b，请你输出 $C_{b}^{a} \mod (10^9+7)$ 的值。

#### 输入格式

第一行包含整数 n。

接下来 n 行，每行包含一组 a 和 b。

#### 输出格式

共 n 行，每行输出一个询问的解。

#### 数据范围

1≤n≤10000,
1≤b≤a≤10^5

#### 输入样例：

```
3
3 1
5 3
2 2
```

#### 输出样例：

```
3
10
1
```



#### 解答与思路

此题的询问数的数据不同，如果按照上一题的思路, 时间复杂度为$O(a^2) = 1e10$, 一定会超时，因此需要用其它方法。

$C_{b}^{a} = \frac{a!}{(a-b)! b!}$， 利用这个公式来求解，又由于除法的取模运算不太方便，容易爆数据量，所以将除法转换成乘法加取模的形式，即使用乘法逆元的方法（且1e9+7是一个质数，可以采用快速幂的方法求逆元）

$C_{b}^{a}  = fact[a] \times infact[a-b] \times infact[b] $

时间复杂度为$O(Nlogmod)$

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 1e5 + 10, mod = 1e9 + 7;

typedef long long LL;

LL fact[N], infact[N];

LL qmi(LL a, LL k, LL p){
    LL res = 1;
    while(k){
        if( k & 1)  res = (LL) res * a % p;
        a = (LL) a * a % p;
        k >>= 1;
    }
    return res;
}


int main(){
    
    fact[0] = infact[0] = 1;
    for(int i = 1; i < N; i ++)
    {
        fact[i] = fact[i - 1] * i % mod;
        infact[i] = qmi(fact[i], mod - 2, mod) % mod;			// 这一步和下面一步都可以
        // infact[i] = infact[i-1] * qmi(i, mod - 2, mod) % mod;
    }
    
    int n;
    scanf("%d", &n);
    while(n --){
        int a,b;
        scanf("%d%d", &a, &b);
        LL res = (LL)fact[a] * infact[a-b] % mod * infact[b] % mod;
        printf("%ld\n", res);
    }
    
    return 0;
}
```

> 注意：数据范围如果计算不清楚，直接使用LL就好了，没必要用int再转换为LL, 除非之后工程内存上的严格要求。



## 容斥原理

原理：在考虑一个计数问题，要确保所有的计数没有重复，没有遗漏。为了使集合重叠部分不被重复计算，人们研究出一种新的计数方法，这种方法的基本思想：先把包含于某个集合中的所有对象的数目计算出来，再把计数时重复计算的数目排斥出去；这种计算方式叫做容斥原理。



![image-20211022101322194](组合计数-容斥原理-简单博弈论.assets/image-20211022101322194.png)

上图是三个集合的韦恩图，把每一个大集合分别记作A,B,C；它的容斥关系公式如下：

$|A \cup B \cup C| = |A| + |B| + |C| - |A \cap B| - |A \cap C| - |B \cap C| + |A \cap B \cap C|$

所以对于一般情况：

n个集合相互容斥，所有计数个数计算公式为:

$ |S1| - |S2| + |S3| - |S4| + ... + (-1)^{n-1}|Sn|$

S1表示所有1个集合数目中的元素个数的和， S2表示所有2个集合交集的情况....



那么对于有n个集合的一般情况下，上述公式展开后有多少项呢？

所有1个集合的数目有 $C_{n}^{1}$个，所有2个集合的交集的情况个数有$C_{n}^{2}$, 所有3个集合交集的情况个数有$C_{n}^{3}$， n个集合交集的情况数目有$C_{n}^{n}$。 

总的展开项有 $C_{n}^{1} + C_{n}^{2}+C_{n}^{3} + .. + C_{n}^{n} = 2^{n} - 1$个。

我们把每一项用一个**m位的二进制数**来表示，比如m = 5，总共有5个集合A,B,C,D,E相互容斥，其中一个（状态）二进制数为00101; 那么我们要求的项是是|S2|中的 A和C的交集的个数。



系数$(-1)^{n-1}$中n就是当前的状态表示, 即二进制数中有多少个1。

时间复杂度$O(2^n)$。

### 容斥原理应用经典例题

给定一个整数 n 和 m 个不同的质数$ p_1,p_2,…,p_m$。

请你求出 1∼n 中能被 $ p_1,p_2,…,p_m$ 中的至少一个数整除的整数有多少个。

#### 输入格式

第一行包含整数 n 和 m。

第二行包含 m 个质数。

#### 输出格式

输出一个整数，表示满足条件的整数的个数。

#### 数据范围

1≤m≤16,
$1≤n,pi≤10^9$

#### 输入样例：

```
10 2
2 3
```

#### 输出样例：

```
7
```



#### 解答和思路

1~10中能被2整除的数有{2,4,6,8,10}, 能被3整除的数有： {3,6,9}，既能被2整除，又能被3整除的数有:{ 6} 。所以所有满足条件的个数为5 + 3 - 1 = 7.

对于该题，我们不需要知道能被某个质数整除的数具体是哪些，只需要知道能被它整除的数有多少个，即集合中的个数： $\lfloor \frac{n}{2} \rfloor$, 如果要求既能被2整除，又能被3整除的数有多少个，由于题目中都是质数，所以它们的乘积就是它们的最小公倍数，个数就是|n / (2 *3)|。 





```c++
 #include<bits/stdc++.h>

using namespace std;

const int N = 20;
int p[N];
typedef long long LL;
int n,m;
int main(){
    scanf("%d%d", &n, &m);
    for(int i = 0; i < m; i ++)
        scanf("%d", &p[i]);
        
    int res = 0;			// 用res表示最后的结果
    for(int i = 1; i < (1 << m); i ++){     	// 1 << m : 1右移m位表示2^m, 初始化为1表示至少选择第一个集合
        int t = 1;						// 用t来表示质数乘积，它们的最小公倍数
        int s = 0;						// 用s来表示多少个集合交集的个数，用于后面判断正负号
        for(int j = 0; j < m; j++){			// 分别枚举m位二进制数中的每一位
            if( i >> j & 1){				//如果是1, 表示选用第j个集合
                if((LL) t * p[j] > n){			// 乘积大于n， 不能在24行更新t， 否则 n / t = 0， 
                    t = -1;
                    break;
                }
                t *= p[j];
                s++;
            }
        }
        
        if(t == -1) continue;
        if(s & 1)   res += n / t;			// 如果s是奇数，（-1）^{n-1}是正数
        else    res -= n / t;
        
    }
    printf("%d", res);
    
    return 0;
}
```











## 简单博弈论