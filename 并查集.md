## 并查集

基本操作：在近乎O(1)的时间复杂度之内，完成这两个操作。

1. 将两个集合合并。
2. 询问两个元素是否在同一个集合当中。



暴力做法：

设置一个belong数组，存储目标数所在的集合，比如belong[x] = a, 表示数x属于集合a; 

如果要询问两个元素是否在同一个集合当中：

```c++
if(belong[x] == belong[y])   // 时间复杂度O(1)
```

但是如果要将两个集合合并，比如一个集合中有1000个元素，另一个集合中有2000个元素；合并后的集合总共三千个元素，暴力做法会：

```c++
for( Collection A ){
    belong[a] = belong[B]     //时间复杂度为O(n)
}
```



---

基本思想：

用树（不一定是二叉树）的方式来维持每一个集合, 树根的编号就是整个集合的编。每个节点存储它的父结点，`p[x] 表示x的父结点`。

问题1： 如何判断树根？`if(p[x] == x)`

问题2： 如何求X的集合编号?  `while(p[x] != x)  x = p[x];`     **这里的时间复杂度是树的高度**。

问题3： 如何合并两个集合？

px 是 x的集合编号，py 是y的集合编号， `p[x] = y`



问题2可以进行优化（**路径压缩优化**）：一旦找到一条路径的根节点编号，就将这条路上的所有结点的父结点直接指向该集合的根节点。

 ![image-20210730114016943](并查集.assets/image-20210730114016943.png)