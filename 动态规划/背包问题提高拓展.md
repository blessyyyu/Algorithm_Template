## 背包问题提高拓展

### 装箱问题

> (Acwing提高班装箱问题)[https://www.acwing.com/problem/content/1026/]

有一个箱子容量为 V，同时有 n 个物品，每个物品有一个体积（正整数）。

要求 n 个物品中，任取若干个装入箱内，使箱子的剩余空间为最小。



题意分析：

常见的背包问题中，有体积、价值两个因素，通常要求体积不超过总体积，价值最大；而这里要求，体积不超过总体积，体积最大。

因此可以将一个物品的价值 = 它的体积，利用0-1背包的通用解法来解决。

```c++
#include <iostream>
using namespace std;

const int N = 20010;
int f[N];

int n, m;
int main(){
    cin >> m;
    cin >> n;
    // 这里将体积输入与动态规划计算放在一个for循环里，可以减少对于空间的占用。
    for(int i = 1; i <= n; i ++){
        int v;
        cin >> v;
        for(int j = m; j >= v; j --){
            f[j] = max(f[j], f[j - v] + v);    
        }
    }
    cout << m - f[m] << endl;
    return 0;
}
```



### 二维费用背包问题





#### 二维费用中其中某一维最少

> (Acwing宠物小精灵)[https://www.acwing.com/problem/content/1024/]

题目中的二维费用有： 1. 精灵球的数量，要求不能超过小智拥有的总数量。 2. 皮卡丘的体力，要求大于0，并且保存的体力越多越好。

价值： 收获的宠物小精灵的个数。

所以原动态规划状态表示数组： `f[i][j][z]`,  `i`表示从1 ~i 个宠物中挑选； `j`表示不超过`j`个精灵球； `z`表示皮卡丘的体力。

压缩空间后： `f[j][z]`; 

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 110, M = 1010;
int n, m, k;

int f[M][M];
int main(){
    cin >> n >> m >> k;
    // v1: the count of ball.
    // v2: the consume of body value.
    int v1, v2;
    
    for(int i = 1; i <= k; i ++){
        cin >> v1 >> v2;
        for(int j = n; j >= v1; j --){
            // 注意这里的z - 1 >= v2， 'z - 1' 的目的是皮卡丘的体力不能为0
            for(int z = m; z - 1 >= v2 ; z --){
                f[j][z] = max(f[j][z], f[j - v1][z - v2] + 1);
            }
        }
    }
    // 下面这2句是关键，要让收获的精灵球数量最多的情况下，皮卡丘剩下保持的体力越多，即：
    // 倒着遍历第二维的体力值，寻找到最少的下标。 一行中具体值： f[n][1] ~ f[n][x1] = 0; f[n][x1+1] ~ f[n][x2] = 1...
    int p = m;
    while(p > 0 && f[n][p] == f[n][m])  p --;
    
    cout << f[n][m] << " " << m - p << endl;
    return 0;
}
```





### 0-1背包求方案数

> [Acwing数字组合](https://www.acwing.com/problem/content/280/)

给定 $N$ 个正整数 $A_1,A_2,…,A_N$从中选出若干个数，使它们的和为 M，求有多少种选择方案。

**题意分析：**

挑选数，每个数都只有1个，并且有选择和不选两种情况，所以是0-1背包。将M看成是背包总体积，因此要求的是背包恰好装满一定的体积。

不压缩的版本：

- 状态表示：设`f[i][j]`中， `i`表示从第`1~i`个数中选，`j`表示选择的数的和恰好是`j`；

- 属性： `f[i][j]`的属性是: count. 表示方案数。

- 状态计算： `f[i][j] = f[i-1][j] + f[i-1][j - nums[i]]`. (即不选择第`i`个数，总和达到`j`的方案数 + 选择第`i`个数，总和达到`j`的方案数)

```c++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;
const int N = 110, M = 10010;

int n, m;
int f[N][M];
int nums[N];

int main(){
    cin >> n >> m;
    for(int i = 1; i <= n; i ++){
        cin >> nums[i];
    }
    // 注意：背包问题求方案数中, f[0][0] = 1， 这个条件必须要有.
    f[0][0] = 1;
    for(int i = 1; i <= n; i ++){
        for(int j = 0; j <= m; j ++){
            f[i][j] = f[i-1][j];
            if( j >= nums[i])
                f[i][j] += f[i-1][j-nums[i]];
        }
    }
    
    cout << f[n][m] << endl;
    return 0;
}
```



压缩维度，滚动数组版本：

```c++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;
const int N = 110, M = 10010;

int n, m;
int f[M];
int nums[N];

int main(){
    cin >> n >> m;
    for(int i = 1; i <= n; i ++){
        cin >> nums[i];
    }
    f[0] = 1;
    for(int i = 1; i <= n; i ++){
        // 倒着遍历
        for(int j = m; j >= nums[i]; j --){
            f[j] += f[j - nums[i]];
        }
    }
    cout << f[m] << endl;
    return 0;
}
```





### 完全背包求方案数

> [Acwing买书](https://www.acwing.com/problem/content/1025/)

小明手里有n元钱全部用来买书，书的价格为10元，20元，50元，100元。

问小明有多少种买书方案？（每种书可购买多本）

输入n, 代表总共钱数。输出一个整数，表示可以选择的方案个数。



**题意分析**：将书的价格看成背包问题中物品的体积。由于每本数都可以重复购买，并且没有数量限制，因此可以看成完全背包问题。

买书不要求价格正好覆盖所有要花的钱，

- 状态表示： `f[i][j]` 中，`i`表示从书的第`1 ~ i`种价格里挑选，总价格不超过`j`的所有购买方案集合。
- 属性： count. 表示`f[i][j]`里购买方案的总数。
- 状态计算： `f[i][j] = f[i-1][j] + f[i-1][j - v[i]] + f[i-1][j - 2 * v[i]] + ... + f[i-1][j - k * v[i]]`; 这里涉及完全背包问题的经典优化方法： `f[i][j] = f[i-1][j] + f[i][j - v[i]]`

![image-20220613210331166](背包问题提高拓展.assets/image-20220613210331166-16551254135511.png)

所以不压缩的版本：

```c++
#include <iostream>
using namespace std;

const int N = 5, M = 1010;
int v[N], f[N][M];
int m;
int main(){
    cin >> m;
    v[1] = 10;
    v[2] = 20;
    v[3] = 50;
    v[4] = 100;
    // 初始化方案数
    f[0][0] = 1;
    for(int i = 1; i <= 4; i ++){
        for(int j = 0; j <= m; j ++){
            f[i][j] = f[i-1][j];
            for(int k = 1; j - k * v[i] >= 0; k ++){
                f[i][j] += f[i-1][j - k * v[i]];
            }
        }
    }
    cout << f[4][m] << endl;
    return 0;
}
```



压缩背包版本：

```c++
#include <iostream>
using namespace std;

const int N = 5, M = 1010;
int v[N], f[M];
int m;
int main(){
    cin >> m;
    v[1] = 10;
    v[2] = 20;
    v[3] = 50;
    v[4] = 100;
    
    f[0] = 1;
    for(int i = 1; i <= 4; i ++){
        for(int j = v[i]; j <= m; j ++){
            f[j] += f[j - v[i]];
        }
    }
    cout << f[m] << endl;
    return 0;
}
```





### 混合背包问题

> [混合背包问题](https://www.acwing.com/problem/content/7/)

有 N 种物品和一个容量是 V 的背包。

物品一共有三类：

- 第一类物品只能用1次（01背包）；
- 第二类物品可以用无限次（完全背包）；
- 第三类物品最多只能用 $s_i$ 次（多重背包）；

每种体积是 $v_i$，价值是 $w_i$。

求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。
输出最大价值。



题意分析： 这个题目将三种常见的背包问题混合起来，在同一个背包体积下，求最优解。

0-1背包：
$$
f[i][j] = max(f[i-1][j], f[i-1][j-v[i]] + w[i])
$$
完全背包：
$$
f[i][j] = max(f[i-1][j], f[i][j - v[i]] + w[i])
$$
多重背包：
$$
f[i][j] = max(f[i-1][j], f[i-1][j - v[i]] + w[i], f[i-1][j - 2*v[i]] + 2*w[i], ...)
$$
分析以上三种背包问题的公式，可以看到，无论选择哪种方法，实际上方法只影响当前“层”的计算公式，而不会影响之前的结果。

所以每次计算新一层（即考虑当前物品要不要选择）结果的时候，判断一下这个物品是哪一种背包模式，根据模式选择公式计算。

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

const int N = 1010;

int f[N];
int n, m;

int main(){
    cin >> n >> m;
    for(int i = 1; i <= n; i ++){
        int v, w, s;
        cin >> v >> w >> s;
        if(s == 0){         // 完全背包
            for(int j = v; j <= m; j ++){
                f[j] = max(f[j], f[j - v] + w);
            }
        }else{
            if(s == -1) s = 1;      // 多重背包
            for(int k = 1; k <= s; k *= 2){
                for(int j = m; j >= k * v; j --)
                    f[j] = max(f[j], f[j - k * v] + k * w);
                s -= k;
            }
            if(s){
                for(int j = m; j >= s * v; j --){
                    f[j] = max(f[j], f[j - s * v] + s * w);
                }
            }
        }
    }
    cout << f[m] << endl;
    return 0;
}
```

