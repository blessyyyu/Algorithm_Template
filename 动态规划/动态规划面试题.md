# 动态规划面试题

### 经典面试题：鸡蛋硬度

> https://www.acwing.com/problem/content/1050/

如果鸡蛋的个数不受限制，可以用二分法，时间复杂度为O(logn)级别；现在考虑使用动态规划算法来求解问题。

设`f[i][j]`表示测量区间长度`i`，使用`j`个鸡蛋在最优策略最坏情况下的丢鸡蛋次数。j个鸡蛋在足够多的情况下也可以不用全部使用完。

为什么可以这么设置状态，测量区间的长度而不是楼层高度的绝对值。因为在第`i`层扔下鸡蛋和在第`j`层扔下鸡蛋的效果i是一致的，都只能判断一半的区间。

- 状态转移： 
  - 不使用第j个鸡蛋，方案数为`f[i][j-1]`；
  - 使用第j个鸡蛋，对第j个鸡蛋的投掷情况进行划分，一共有1~i层楼可以扔，假设在第k层楼扔:
    - 蛋碎了，搜索区间变成1 ~ k -1 ， 方案数为`f[k-1][j-1]`
    - 蛋没碎，搜索区间变成k + 1 ~ i, 鸡蛋个数为j， 方案数为`f[i-k][j]`
  - 枚举所有扔的楼层k，**最坏情况指的是蛋碎或者蛋不碎方案中的最大值（不能控制的）， 最优策略指这些情况中的最小值**。时间复杂度为$O(n^2m)$

```c++
#include<bits/stdc++.h>

using namespace std;
int n, m;
int f[110][20];
int main(){
    while(cin >> n >> m){
        memset(f, 0, sizeof f);
        // 初始化边界
        for(int i = 1; i <= n; i ++)    f[i][1] = i;
        for(int i = 1; i <= m; i ++)    f[1][i] = 1;

        for(int i = 2; i <= n; i ++){
            for(int j = 2; j <= m; j ++){
                f[i][j] = f[i][j-1];
                for(int k = 1; k <= i; k ++){
                    f[i][j] = min(f[i][j], max(f[k-1][j-1], f[i-k][j]) + 1);
                }

            }
        }

        cout << f[n][m]<< endl;       
    }

    return 0;
}
```



### 异或和是质数的子集数-- hulu面试题

> https://www.acwing.com/problem/content/description/1456/

给出 n 个**互不相同**的正整数。

问存在多少个子集，使得子集中所有数的异或和是质数。

由于答案可能很大，请你输出对 $10^9+7$ 取模后的结果。

**输入格式**

第一行包含整数 n。

第二行包含 n 个正整数。

 **输出格式**

输出一个整数，表示满足条件的子集数量对 $10^9+7$ 取模后的结果。

**数据范围**

1≤n≤5000
1≤ 给定正整数 ≤5000

 **输入样例：**

```
3
1 2 3
```

**输出样例：**

```
4
```



**思路与解答：**

什么叫做异或和？ 因为异或还有个名字：不进位加法，所以异或和就是一堆数一直做异或运算，比如：1,2,3的异或和 =  1 ^ 2 ^ 3 = 0;

由于数据范围最大不超过5000， 异或是二进制运算，2^12 = 4096 < 5000, 所以即使是异或后的数，它的二进制表示不超过13位。

$2^{12} + 2^{11} + 2^{10} + ... + 2 + 1 = 8191;$

判断异或和可以直接使用试除法，一个数的时间复杂度为$O(\sqrt{num})$，全部数据的复杂度为$O(n\sqrt{num}) = 60000$，不会超时。

再看样例，集合中有3个数，分别是1，2，3； 它所构成的集合有2^3 = 8个，每一个元素的选和不选是2种方案，乘起来。

重点：**对于这种从一堆元素中挑选元素，达到指定的要求的题目，就是符合01背包的性质，可以用01背包来解决。**

- 状态集合：`f[i][j] = x`， 所有只考虑前i个数字，且它们的异或和是j的所有选法的集合。
- 属性：count，集合中的个数是多少。
- 状态计算： `f[i][j] = f[i-1][j] + f[i-1][j ^ a[i]]`；

滚动数组的计算：由于第i层的`f[i][j]`只与上一层有关，所以第一维我们可以只开辟两个数，`f[0][j]`和`f[1][j]`；

`f[1][j] = f[0][j] + f[0][j ^ a[i]];     f[0][j] = f[1][j] + f[1][j ^ a[i]]`



```c++
#include<bits/stdc++.h>
using namespace std;

const int N = 5010, M = 8192, MOD = 1e9 + 7;
int a[N];
int res, n;
int f[2][M];

bool is_prime(int x){
    for(int i = 2; i <= x / i; i ++){
        if(x % i == 0){
            return false;
        }
    }
    return true;
}


int main(){
    scanf("%d", &n);
    for(int i = 1; i <= n; i ++){
        scanf("%d", &a[i]);
    }
    // dp数组初始化，即没有数字可选，但是要达到异或和为0，正好有1种选法：即什么都不选。
    f[0][0] = 1;
    
    for(int i = 1; i <= n; i ++){
        for(int j = 0; j < M; j ++){
            // 使用滚动数组
            f[i & 1][j] = f[(i-1) & 1][j];
            if((j ^ a[i]) < M){
                f[i & 1][j] += f[(i-1) & 1][j ^ a[i]] ;
                f[i & 1][j] %= MOD;
            }
        }
    }
    
    for(int i = 2; i < M; i ++){
        if( is_prime(i) ){
            res = (res + f[n & 1][i]) % MOD;
        }
    }
    
    cout << res << endl;
    return 0;

}
```





### 正则表达式构建

> https://leetcode-cn.com/problems/regular-expression-matching/

给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖**整个**字符串s的，而不是部分字符串。

 **示例 1：**

```
输入：s = "aa", p = "a"
输出：false
解释："a" 无法匹配 "aa" 整个字符串。
```



**思路与解答：**

经验：两个字符串的题目，一般都是双指针 + 动态规划的思路。

- 状态表示：`f[i][j]`表示`s[1~i]`（下标更改一下，从1开始）和 `p[1~j]` 的所有匹配情况。
- 属性: `bool`, 表示是否存在一个合法匹配方案。（通常用或运算有奇效。）
- 状态计算：

分为两种情况：1. `p[j] != '*'`，平凡转移， 如果`s[i] == p[j] || p[j] == '.'`， 则`f[i][j] = f[i][j] | f[i-1][j-1]`;

2.`p[j] == '*'`, 则有两种情况，`f[i][j] = f[i][j] | f[i][j-2]`, 这里它可以让`s[1~i]和p[1~(j-2)]`做匹配，表示'*'取0个字符；如果`s[i] == p[j-1] || p[j-1] == '.'`时， `f[i][j] = f[i][j] | f[i-1][j]`

> 题解清楚版： https://www.acwing.com/solution/content/557/

注意：难点在于`f[i][j]`为什么可以由`f[i-1][j]`转移过来，两种思考方法：

1. 由于`(s[i] == p[j-1] || p[j-1] = '.' ) && p[j] == '*'`， 则相当于`s[i]`一个字符可以抵消掉`p[j-1][j]`两个字符的效果。
2. 用完全背包的思路，对'*'符号复制出k份，再进行一次划分。

```c++
class Solution {
public:
    bool isMatch(string s, string p) {
        int n = s.size(), m = p.size();
        vector<vector<bool>> f(n + 1, vector<bool>(m + 1 , false));
        f[0][0] = true;
        // 对齐处理
        s = " " + s;
        p = " " + p;
        // i从0开始，是因为s串为空串也是可以匹配成功的，比如 "" 和 "a*"
        for(int i = 0; i <= n; i ++) {
            // j从1开始，是因为模板串为0，只有f[0][0]一种情况为true,其余都为false
            for(int j = 1; j <= m; j ++){
                if( i > 0 && ( p[j] == s[i] || p[j] == '.' )){
                    f[i][j] = f[i][j] | f[i-1][j-1] ;
                }

                if(p[j] == '*'){
                    if(j >= 2)
                        f[i][j] = f[i][j] | f[i][j-2];
                    if(i > 0 && (s[i] == p[j-1] || p[j-1] == '.'))
                        f[i][j] = f[i][j] | f[i-1][j];
                }
            }
        }
        return f[n][m];
    }
};
```

