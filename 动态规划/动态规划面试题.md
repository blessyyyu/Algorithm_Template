# 动态规划面试题

### 经典面试题：鸡蛋硬度

> https://www.acwing.com/problem/content/1050/

#### 思路一：

如果鸡蛋的个数不受限制，可以用二分法，时间复杂度为O(logn)级别；现在考虑使用动态规划算法来求解问题。

设`f[i][j]`表示测量区间长度`i`，使用`j`个鸡蛋在最优策略最坏情况下的丢鸡蛋次数。j个鸡蛋在足够多的情况下也可以不用全部使用完。

为什么可以这么设置状态，测量区间的长度而不是楼层高度的绝对值。因为在第`i`层扔下鸡蛋和在第`j`层扔下鸡蛋的效果i是一致的，都只能判断一半的区间。

- 状态转移： 
  - 不使用第j个鸡蛋，方案数为`f[i][j-1]`；
  - 使用第j个鸡蛋，对第j个鸡蛋的投掷情况进行划分，一共有1~i层楼可以扔，假设在第k层楼扔:
    - 蛋碎了，搜索区间变成1 ~ k -1 ， 方案数为`f[k-1][j-1]`
    - 蛋没碎，搜索区间变成k + 1 ~ i, 鸡蛋个数为j， 方案数为`f[i-k][j]`
  - 枚举所有扔的楼层k，**最坏情况指的是蛋碎或者蛋不碎方案中的最大值（不能控制的）， 最优策略指这些情况中的最小值**。时间复杂度为$O(n^2m)$

```c++
#include<bits/stdc++.h>

using namespace std;
int n, m;
int f[110][20];
int main(){
    while(cin >> n >> m){
        memset(f, 0, sizeof f);
        // 初始化边界
        for(int i = 1; i <= n; i ++)    f[i][1] = i;
        for(int i = 1; i <= m; i ++)    f[1][i] = 1;

        for(int i = 2; i <= n; i ++){
            for(int j = 2; j <= m; j ++){
                f[i][j] = f[i][j-1];
                for(int k = 1; k <= i; k ++){
                    f[i][j] = min(f[i][j], max(f[k-1][j-1], f[i-k][j]) + 1);
                }

            }
        }

        cout << f[n][m]<< endl;       
    }

    return 0;
}
```



