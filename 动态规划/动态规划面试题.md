# 动态规划面试题

### 经典面试题：鸡蛋硬度

> https://www.acwing.com/problem/content/1050/

如果鸡蛋的个数不受限制，可以用二分法，时间复杂度为O(logn)级别；现在考虑使用动态规划算法来求解问题。

设`f[i][j]`表示测量区间长度`i`，使用`j`个鸡蛋在最优策略最坏情况下的丢鸡蛋次数。j个鸡蛋在足够多的情况下也可以不用全部使用完。

为什么可以这么设置状态，测量区间的长度而不是楼层高度的绝对值。因为在第`i`层扔下鸡蛋和在第`j`层扔下鸡蛋的效果i是一致的，都只能判断一半的区间。

- 状态转移： 
  - 不使用第j个鸡蛋，方案数为`f[i][j-1]`；
  - 使用第j个鸡蛋，对第j个鸡蛋的投掷情况进行划分，一共有1~i层楼可以扔，假设在第k层楼扔:
    - 蛋碎了，搜索区间变成1 ~ k -1 ， 方案数为`f[k-1][j-1]`
    - 蛋没碎，搜索区间变成k + 1 ~ i, 鸡蛋个数为j， 方案数为`f[i-k][j]`
  - 枚举所有扔的楼层k，**最坏情况指的是蛋碎或者蛋不碎方案中的最大值（不能控制的）， 最优策略指这些情况中的最小值**。时间复杂度为$O(n^2m)$

```c++
#include<bits/stdc++.h>

using namespace std;
int n, m;
int f[110][20];
int main(){
    while(cin >> n >> m){
        memset(f, 0, sizeof f);
        // 初始化边界
        for(int i = 1; i <= n; i ++)    f[i][1] = i;
        for(int i = 1; i <= m; i ++)    f[1][i] = 1;

        for(int i = 2; i <= n; i ++){
            for(int j = 2; j <= m; j ++){
                f[i][j] = f[i][j-1];
                for(int k = 1; k <= i; k ++){
                    f[i][j] = min(f[i][j], max(f[k-1][j-1], f[i-k][j]) + 1);
                }

            }
        }

        cout << f[n][m]<< endl;       
    }

    return 0;
}
```



### 异或和是质数的子集数-- hulu面试题

> https://www.acwing.com/problem/content/description/1456/

给出 n 个**互不相同**的正整数。

问存在多少个子集，使得子集中所有数的异或和是质数。

由于答案可能很大，请你输出对 $10^9+7$ 取模后的结果。

**输入格式**

第一行包含整数 n。

第二行包含 n 个正整数。

 **输出格式**

输出一个整数，表示满足条件的子集数量对 $10^9+7$ 取模后的结果。

**数据范围**

1≤n≤5000
1≤ 给定正整数 ≤5000

 **输入样例：**

```
3
1 2 3
```

**输出样例：**

```
4
```



**思路与解答：**

什么叫做异或和？ 因为异或还有个名字：不进位加法，所以异或和就是一堆数一直做异或运算，比如：1,2,3的异或和 =  1 ^ 2 ^ 3 = 0;

由于数据范围最大不超过5000， 异或是二进制运算，2^12 = 4096 < 5000, 所以即使是异或后的数，它的二进制表示不超过13位。

$2^{12} + 2^{11} + 2^{10} + ... + 2 + 1 = 8191;$

判断异或和可以直接使用试除法，一个数的时间复杂度为$O(\sqrt{num})$，全部数据的复杂度为$O(n\sqrt{num}) = 60000$，不会超时。

再看样例，集合中有3个数，分别是1，2，3； 它所构成的集合有2^3 = 8个，每一个元素的选和不选是2种方案，乘起来。

重点：**对于这种从一堆元素中挑选元素，达到指定的要求的题目，就是符合01背包的性质，可以用01背包来解决。**

- 状态集合：`f[i][j] = x`， 所有只考虑前i个数字，且它们的异或和是j的所有选法的集合。
- 属性：count，集合中的个数是多少。
- 状态计算： `f[i][j] = f[i-1][j] + f[i-1][j ^ a[i]]`；

滚动数组的计算：由于第i层的`f[i][j]`只与上一层有关，所以第一维我们可以只开辟两个数，`f[0][j]`和`f[1][j]`；

`f[1][j] = f[0][j] + f[0][j ^ a[i]];     f[0][j] = f[1][j] + f[1][j ^ a[i]]`



```c++
#include<bits/stdc++.h>
using namespace std;

const int N = 5010, M = 8192, MOD = 1e9 + 7;
int a[N];
int res, n;
int f[2][M];

bool is_prime(int x){
    for(int i = 2; i <= x / i; i ++){
        if(x % i == 0){
            return false;
        }
    }
    return true;
}


int main(){
    scanf("%d", &n);
    for(int i = 1; i <= n; i ++){
        scanf("%d", &a[i]);
    }
    // dp数组初始化，即没有数字可选，但是要达到异或和为0，正好有1种选法：即什么都不选。
    f[0][0] = 1;
    
    for(int i = 1; i <= n; i ++){
        for(int j = 0; j < M; j ++){
            // 使用滚动数组
            f[i & 1][j] = f[(i-1) & 1][j];
            if((j ^ a[i]) < M){
                f[i & 1][j] += f[(i-1) & 1][j ^ a[i]] ;
                f[i & 1][j] %= MOD;
            }
        }
    }
    
    for(int i = 2; i < M; i ++){
        if( is_prime(i) ){
            res = (res + f[n & 1][i]) % MOD;
        }
    }
    
    cout << res << endl;
    return 0;

}
```

