# 求最短路

## 最短路：

* 单源最短路： 求一个点到其他所有点的最短路问题。
  * 所有边权都是正数
    * 朴素Dijkstra算法，时间复杂度$O(n^2)$， n表示点的数量，m表示边的数量,适合**稠密图**；
    * 堆优化Dijkstra算法，时间复杂度是$O(mlog(n))$; **稠密图m基本是$n^2$级别的**，所以不适合使用；稀疏图适合使用‘
  * 存在负权边
    * Bellman-Ford算法 O(nm)
    * SPFA算法： 对Bellman-Ford算法进行优化，一般O(m)，最坏O(nm)；
* 多源汇最短路：可能不止一个起点，有很多询问，求任意两个点之间的最短路径。 一个算法，**Floyd算法**，时间复杂度：$O(n^3)$

> 图论里的题目侧重于抽象建模。

## 朴素Dijkstra算法

思路：

```c++
初始化距离：dist[1] = 0, 其他所有点到起点的距离dist[i] = 无穷;
初始化集合st : 当前已确定最短距离的点;
循环 for i : 1~n
    t <-不在s中的，距离最近的点
    st <- 用t来更新st集合中所有点的距离：
    	dist[x] > dist[t] + w (从1号点走到x的距离,是否大于,从1号点走到t,再从t走到x)
得到起点到每一个点的最短距离；
```



稠密图：用邻接矩阵来存，稀疏图：用邻接表来存

### 经典例题：朴素Dijkstra求最短路

给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环，所有边权均为正值。

请你求出 1 号点到 n 号点的最短距离，如果无法从 1 号点走到 n 号点，则输出 −1。

#### 输入格式

第一行包含整数 n 和 m。

接下来 m 行每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。

#### 输出格式

输出一个整数，表示 1 号点到 n 号点的最短距离。

如果路径不存在，则输出 −1。

#### 数据范围

$1≤n≤500$
$1≤m≤10^5$
图中涉及边长均不超过10000。

#### 输入样例：

```
3 3
1 2 2
2 3 1
1 3 4
```

#### 输出样例：

```
3
```





#### 解答

```c++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 510;

int n,m;
// 由题目的意思可知，稠密图最好使用邻接矩阵存储
int g[N][N];
// dist[]存储起点到每个结点的距离
int dist[N];
// st[]表示某个结点是否已经确认是最短的
bool st[N];

int dijkstra(){
    // 初始化距离数组
    memset(dist, 0x3f, sizeof dist);
    // 起点设置为最短0
    dist[1] = 0;
    for(int i = 0; i < n; i++){
        int t = -1;
        // 找待定的，距离最短的点，设置为t
        for(int j = 1; j<=n; j++){
            
            if(!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;
        }
        
        st[t] = true;
        
        for(int j = 1; j <=n; j++){
            dist[j] = min(dist[j], dist[t] + g[t][j]);
        }
    }
    // 到达不了n结点，没有最短路，返回-1
    if(dist[n] == 0x3f3f3f3f)   return -1;
    else    return dist[n];
}


int main(){
    scanf("%d%d", &n,&m);

    memset(g,0x3f, sizeof(g));
    
    while(m --){
        int a,b,c;
        scanf("%d%d%d",&a,&b,&c);
        // 如果有重边，将距离设置为最短的
        g[a][b] = min(g[a][b],c);
    }
    
    int t = dijkstra();
    
    printf("%d\n", t);
    
    return 0;
    
    
}
```



## 堆优化版的Dijkstra算法

引入的原因：朴素的Dijkstra算法适用于稠密图，但是如果边和点的数量都在$10^5$级别，$n^2就是10^{10}级别$, 会超时；所以系数图需要使用堆优化版的Dijkstra算法；

看到47分钟;

